import{_ as n,p as s,q as a,J as t}from"./framework-4a7f5a2b.js";const p={},e=t(`<h2 id="起因" tabindex="-1"><a class="header-anchor" href="#起因" aria-hidden="true">#</a> 起因</h2><p>项目上的登录思路是做一次请求与后台换取 token 信息并储存在 localStorage 上，这样会在限定时间内用户发出的请求都会使用缓存上的 token，避免每次请求的用户鉴权，也实现了短期的免登录。</p><p><strong>登录页面示例代码：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 1.获取 token 并储存在缓存上。res 代指后台返回的 token</span>
localStorage<span class="token punctuation">.</span><span class="token function">setItem</span><span class="token punctuation">(</span><span class="token string">&#39;access_token&#39;</span><span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 2.成功后跳转首页，假设首页需要立即发出请求。</span>
<span class="token keyword">this</span><span class="token punctuation">.</span>$router<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token literal-property property">path</span><span class="token operator">:</span> <span class="token string">&#39;/&#39;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 3.跳转到首页发出需要带有 token 的请求，执行以下请求封装逻辑。</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>请求封装示例代码：</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 4.获取缓存上的 token</span>
<span class="token keyword">const</span> token <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;access_token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 5.使用 axios 封装请求，设置默认 Authorization</span>
axios<span class="token punctuation">.</span>defaults<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>common<span class="token punctuation">[</span><span class="token string">&#39;Authorization&#39;</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Bearer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>token<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span><span class="token punctuation">;</span>
<span class="token comment">// 6.axios 调用接口请求服务,简要示例</span>
axios<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>params<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">...</span>
axios<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>params<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">...</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上看似线性逻辑没有问题，但真正的代码运行时 token 为 undefined。为什么呢？</p><h2 id="一种解决方式" tabindex="-1"><a class="header-anchor" href="#一种解决方式" aria-hidden="true">#</a> 一种解决方式</h2><p>最开始我以为因为异步请求，在储存 token 的时间上，路由先成功跳转后渲染页面，发起了后续的业务请求，使得 token 还未存好就先调用了。</p><p>于是我为路由跳转设置了定时器延时跳转。但是，太天真了，依旧失败。</p><p>那么，使用终极大招 <code>window.location.href</code> 跳转！</p><p>确实成功了，页面刷新时业务请求带上了缓存上的 token。（开森～☺︎）</p><p>但是哪里怪怪的？—— 登录跳转时刷新加载前会有段时间空白页。（惆怅... ☹︎）</p><h2 id="真正的解决方式" tabindex="-1"><a class="header-anchor" href="#真正的解决方式" aria-hidden="true">#</a> 真正的解决方式</h2><p>强迫症的我，终于在有一天仔细去撸这段陈年老代码时发现的猫腻：</p><p>在跳转请求时 token 拿不到是因为加载过早了，但却是因为我把设置 token 定义的太早了。在 import 请求时，请求封装.js 就事先去拿了缓存的 token，而这时缓存还没存呢！</p><p><strong>解决方案：把 const token 和设置 Authorization 放进请求拦截方法里。</strong></p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>request<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>
    <span class="token parameter">config</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token keyword">const</span> token <span class="token operator">=</span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span><span class="token string">&quot;access_token&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         config<span class="token punctuation">.</span>headers<span class="token punctuation">.</span>Authorization <span class="token operator">=</span> <span class="token template-string"><span class="token template-punctuation string">\`</span><span class="token string">Bearer </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">\${</span>token<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">\`</span></span>
         <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token parameter">error</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样即在后续每次请求时，先拿一下缓存的 token 设置 headers.Authorization，然后带着去请求咯。</p><h2 id="反思" tabindex="-1"><a class="header-anchor" href="#反思" aria-hidden="true">#</a> 反思</h2><p>这里问题的原因是没能顾全 import 封装请求的先后顺序，总是单纯的认为把所有定义放在最上面才舒服。</p><p>没有意识到变量定义和 axios 初始设置从页面初始化时就已经加载完毕了。</p><p>而上面第一种方式恰好是在缓存之后，把页面刷新 js 重载（这时 token 毫无疑问在缓存里）。</p>`,23),o=[e];function c(i,l){return s(),a("div",null,o)}const r=n(p,[["render",c],["__file","22101804.html.vue"]]);export{r as default};
