import{_ as t,p as e,q as r,w as l,J as d}from"./framework-4a7f5a2b.js";const o={},a=d('<h2 id="疑问" tabindex="-1"><a class="header-anchor" href="#疑问" aria-hidden="true">#</a> 疑问</h2><p>ES6标准入门文档-编程风格（规范）有一段：</p><blockquote><p><code>使用import取代require()</code></p><p><code>使用export取代module.exports</code></p></blockquote><p>在函数封装上，使用require和import都会实现调用需求。这里大佬却建议多用后者，这使我疑惑。为了弄清缘由，于是查阅对比了下来。</p><h2 id="对比" tabindex="-1"><a class="header-anchor" href="#对比" aria-hidden="true">#</a> 对比</h2><table><thead><tr><th style="text-align:left;"><strong>require / module.exports exports</strong></th><th style="text-align:left;"><strong>Important / export (export default)</strong></th></tr></thead><tbody><tr><td style="text-align:left;">CommonJs（CJS）<br>AMD规范引入方式</td><td style="text-align:left;">ESModule(ESM) ECMAScript(ES)<br>ES6语法标准</td></tr><tr><td style="text-align:left;">动态评估，再运行时报错，不是关键词</td><td style="text-align:left;">静态评估，再解析时报错，是关键词</td></tr><tr><td style="text-align:left;">运行时调用（任何地方就都可调用）</td><td style="text-align:left;">编译时调用（必须在头部）</td></tr><tr><td style="text-align:left;">引入基础数据类型时，属于复制该变量<br>引入复杂数据类型时，数据浅拷贝该对象<br>默认export的是一个对象，即使导出的是基础数据类型</td><td style="text-align:left;">import为了实现动态加载， 引入了<code>import()</code>函数， 该函数返回一个promise对象</td></tr><tr><td style="text-align:left;">存在缓存，再次调用需要清除</td><td style="text-align:left;">--</td></tr><tr><td style="text-align:left;">值拷贝</td><td style="text-align:left;">值引用</td></tr><tr><td style="text-align:left;">依赖node环境</td><td style="text-align:left;">NodeJ和浏览器中的未来</td></tr></tbody></table><h2 id="实践对比" tabindex="-1"><a class="header-anchor" href="#实践对比" aria-hidden="true">#</a> 实践对比</h2><p>在测试项目里，我特意在不同页面试用了两种方式。除了写法的不同和加载调用机制不同，运行起来的效果几乎相同。</p><blockquote><p>何时用require？何时用import？</p></blockquote><p>通过寥寥无几的回答，我得出了一个潦草的结论：<strong>尽可能使用import，这是未来的趋势</strong>。</p>',10);function i(n,s){return e(),r("div",null,[l(" more "),a])}const c=t(o,[["render",i],["__file","22012601.html.vue"]]);export{c as default};
